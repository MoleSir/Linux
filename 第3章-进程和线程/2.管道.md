# 管道

## 1. 管道概述

==管道==的是==进程间通信（IPC - InterProcess Communication）==的一种方式；

管道是**内核中的一块内存** (或者叫**内核缓冲区**)，这块缓冲区中的数据存储在一个**环形队列**中，管道在内核区，用户不能直接对其进行操作；

<img src="https://subingwen.cn/linux/pipe/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png" alt="img" style="zoom: 67%;" />

因为管道数据是通过**队列**来维护的，具有以下特定：

- 管道对应的**内核缓冲区**大小是**固定**的，默认为 **4k**（队列最大能存储 4k 数据）


- 管道分为两部分：**读端和写端**（队列的两端），<u>数据从写端进入管道，从读端流出管道</u>。


- 管道中的数据**只能读一次**，做一次读操作之后数据也就没有了（<u>读数据相当于出队列</u>）。


- 管道是**单工**的：数据只能**单向流动**，数据从写端流向读端。


- 对管道的操作（读、写）默认是**阻塞**的

    - 读管道：管道中没有数据，读操作被阻塞，当管道中有数据之后阻塞才能解除
    - 写管道：管道被写满了，写数据的操作被阻塞，当管道变为不满的状态，写阻塞解除

管道操作就是**文件 IO 操作**，内核中管道的两端分别**对应两个文件描述符**，通过<u>写端的文件描述符把数据写入到管道中，通过读端的文件描述符将数据从管道中读出来</u>。读写管道的函数就是 Linux 中的文件 IO 函数；

````c
// 读管道
ssize_t read(int fd, void *buf, size_t count);
// 写管道的函数
ssize_t write(int fd, const void *buf, size_t count);
````

<img src="https://subingwen.cn/linux/pipe/image-20210204211818071.png" alt="img" style="zoom: 33%;" />

在上图，父进程通过一系列操作可以通过文件描述符表中的文件描述符 **fd3** 写管道，通过 **fd4** 读管道；

通过 `fork()` **创建出子进程**，在父进程中被分配的文件描述符 **fd3， fd4** 就被拷贝到子进程，子进程通过 fd3 将数据写入管道，通过 fd4 读管道；

管道**独立于任何进程**，充当了进程**数据通信的载体**，<u>只要两个进程能够得到同一个管道的入口和出口（读端和写端的文件描述符），就可通过管道进行数据交互</u>；





## 2. 匿名管道

==匿名管道==是管道的一种，管道**没有名字**，但其本质不变，就是位于内核中的一块内存，匿名管道拥有上面介绍的管道的所有特性；

<u>匿名管道只能实现**有血缘关系**的进程间通信</u>，比如：父子进程，兄弟进程，爷孙进程，叔侄进程；



### 2.1 创建匿名管道

创建匿名管道的函数为 `pipe`：

````c
#include <unistd.h>
// 创建一个匿名的管道, 得到两个可用的文件描述符
int pipe(int pipefd[2]);
````

- **参数**：传出参数，需要传递一个整形数组的地址，数组大小为 2，也就是说最终会**传出两个元素**
    - `pipefd[0]`: 对应管道**读端**的文件描述符，通过它可以将数据从管道中读出
    - `pipefd[1]`: 对应管道**写端**的文件描述符，通过它可以将数据写入到管道中
- **返回值**：成功返回 0，失败返回 -1；



### 2.2 进程间通信

使用**匿名管道**只能够实现有**血缘关系**的**进程间通信**，要求写一段程序完成下边的功能：

> ​	需求描述:
>
>    在父进程中创建一个子进程, 父子进程分别执行不同的操作:
>    - 子进程: 执行一个 shell 命令 "ps aux", 将命令的结果传递给父进；
>    - 父进程: 将子进程命令的结果输出到终端；

需求分析:

- 子进程中执行 `shell` 命令相当于启动一个**磁盘程序**，因此需要使用 `execl ()/execlp ()` 函数

    - `execlp(“ps”, “ps”, “aux”, NULL)`
- 子进程中执行完 `shell` 命令直接就可以**在终端输出结果**；
    - 数据传递需要使用管道，**子进程**需要将数据**写入到管道中**
    - 将默认输出到终端的数据写入到管道就需要进行输出的重定向，需要使用 `dup2()` 做这件事情
        - `dup2(fd[1], STDOUT_FILENO)` 默认写是到终端，现在把这个文件描述符指向管道写入端；
- **父进程**需要**读管道**，将从管道中读出的数据打印到终端
- 父进程最后需要**释放子进程资源**，防止出现僵尸进程

​	在使用管道进行进程间通信的注意事项，必须要保证数据在管道中的单向流动：

​	**第一步**：<u>在父进程中创建了匿名管道，得到了两个分配的文件描述符，fd3 操作管道的读端，fd4 操作管道的写端</u>。

<img src="https://subingwen.cn/linux/pipe/image-20210204223438269.png" alt="img" style="zoom: 33%;" />

**第二步**：<u>父进程创建子进程，父进程的文件描述符被拷贝，在子进程的文件描述符表中也得到了两个被分配的可以使用的文件描述符，通过 fd3 读管道，通过 fd4 写管道</u>。

​	通过下图可以看到管道中数据的流动不是单向的，有以下这么几种情况：

- 父进程通过 fd4 将数据写入管道，然后父进程再通过 fd3 将数据从管道中读出
- 父进程通过 fd4 将数据写入管道，然后子进程再通过 fd3 将数据从管道中读出
- 子进程通过 fd4 将数据写入管道，然后子进程再通过 fd3 将数据从管道中读出
- 子进程通过 fd4 将数据写入管道，然后父进程再通过 fd3 将数据从管道中读出

管道行为默认是阻塞的，假设子进程通过写端将数据写入管道，父进程的读端将数据读出，这样**子进程的读端就读不到数据**，导致子进程阻塞在读管道的操作上，这样就会给程序的执行造成一些不必要的影响。<u>如果本来也没有打算让进程读或者写管道，那么就可以将进程操作的读端或者写端关闭</u>。

<img src="https://subingwen.cn/linux/pipe/image-20210204224031041.png" alt="img" style="zoom:33%;" />

**第三步**：<u>为了避免两个进程都读管道，但是可能其中某个进程由于读不到数据而阻塞的情况，关闭进程中用不到的那一端的文件描述符，数据只能单向从一端流向另外一端</u>

如下图，关闭父进程的写端，关闭子进程的读端（子进程只能写，父进程只能读）：

<img src="https://subingwen.cn/linux/pipe/image-20210204225930296.png" alt="img" style="zoom:33%;" />

​	根据上面的分析，最终可以写出代码：

````c
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <string.h>


int main()
{
    // 创建匿名管道
    int fd[2];
    int ret = pipe(fd);
    if (ret == -1)
    {
        perror("pipe");
        return -1;
    }


    // 创建子进程
    pid_t pid = fork();
    if (pid == -1)
    {
        perror("fork");
        return -1;
    }

    // 子进程
    if (pid == 0)
    {
        // 关闭读端口
        close(fd[0]);
        // 将标志输出重定向至管道的写端口
        dup2(fd[1], STDOUT_FILENO);
        // 调用
        execlp("ps", "ps", "aux", NULL);
        perror("execlp");
    }
    // 父进程
    else if (pid > 0)
    {
        // 关闭写端口
        close(fd[1]);
        // 从管道中读取数据：
        char buf[1024];
        while(1)
        {
            memset(buf, 0, sizeof(buf));
            int len = read(fd[0], buf, sizeof(buf));
            // read 返回0，说明已经没有内容可以读了
            if (len == 0) break;

            printf("%s, len = %d\n", buf, len);
        }

        // 关闭读
        close(fd[0]);

        // 等待子进程
        wait(NULL);
    }

    return 0;
}
````





## 3. 有名管道

==有名管道==拥有**管道**的所有特性，称之为有名是因为**管道在磁盘上有实体文件**，文件类型为 p ，有名管道文件大小永远为 0；

有名管道也是将<u>数据存储到内存的缓冲区中，打开这个磁盘上的管道文件就可以得到操作有名管道的文件描述符，通过文件描述符读写管道存储在内核中的数据</u>；

**有名管道**也可以称为 ==fifo (first in first out)==，使用有名管道既可以进行**有血缘关系**的进程间通信，也可以进行**没有血缘关系**的进程间通信。



### 3.1 创建有名管道

创建有名管道的方式有两种，一种是通过命令，一种是通过函数。

- **通过命令：**

    ````shell
    $ mkfifo 有名管道的名称
    ````

- **通过函数：**

    ````c
    #include <sys/types.h>
    #include <sys/stat.h>
    // int open(const char *pathname, int flags, mode_t mode);
    int mkfifo(const char *pathname, mode_t mode);
    ````

    - **参数**:

        - `pathname`: 要创建的有名管道的**名字**
        - `mode`: 文件的**操作权限**，和 `open ()` 的第三个参数一个作用，最终权限: `(mode & ~umask)`

    - **返回值**：创建成功返回 0，失败返回 -1


​        

### 3.2 进程间通信

不管是有**血缘**关系还是**没有血缘**关系，使用有名管道实现**进程间通信**的方式是相同的：

就是<u>在两个进程中分别以读、写的方式打开磁盘上的管道文件</u>，得到用于读管道、写管道的文件描述符，就可以调用对应的 `read ()`、`write ()` 函数进行读写操作；

整个过程就像两个进程通过一个磁盘上的文件在进行交流；

> 有名管道操作需要通过 open () 操作得到读写管道的文件描述符，如果只是读端打开了或者只是写端打开了，进程会阻塞在这里不会向下执行，直到在另一个进程中将管道的对端打开，当前进程的阻塞也就解除了；

- **写管道的进程**

    1. **创建**有名管道文件 ：`mkfifo()`

    2. **打开**有名管道文件, 打开方式是 `O_WRDONLY`：`int wfd = open("xx", O_WRONLY)`

    3. **调用**`write`函数写文件 ==> 数据被写入管道中：`write(wfd, data, strlen(data))`

    4. 写完之后**关闭**文件描述符：`close(wfd)`

        PS：文件不能建在与 windows 共享的文件夹里；

    ````c
    #include <fcntl.h>
    #include <sys/stat.h>
    
    int main()
    {
        // 1. 创建有名管道文件
        int ret = mkfifo("./testfifo", 0664);
        if(ret == -1)
        {
            perror("mkfifo");
            exit(0);
        }
        printf("管道文件创建成功...\n");
    
        // 2. 打开管道文件
        // 因为要写管道, 所有打开方式, 应该指定为 O_WRONLY
        // 如果先打开写端, 读端还没有打开, open函数会阻塞, 当读端也打开之后, open解除阻塞
        // 也就是说要等待读端口打开管道的读端
        int wfd = open("./testfifo", O_WRONLY);
        if(wfd == -1)
        {
            perror("open");
            exit(0);
        }
        printf("以只写的方式打开文件成功...\n");
    
        // 3. 循环写管道
        int i = 0;
        while(i<100)
        {
            char buf[1024];
            sprintf(buf, "hello, fifo, 我在写管道...%d\n", i);
            write(wfd, buf, strlen(buf));
            i++;
            sleep(1);
        }
        close(wfd);
    
        return 0;
    }
    ````

- **读管道的进程：**

    1. 这两个进程需要**操作**相同的**管道文件**
    2. **打开**有名管道文件, 打开方式是 `O_RDONLY`：`int rfd = open("xx", O_RDONLY)`
    3. 调用read函数**读文件** ==> 读**管道中的数据**
        `char buf[4096];`
        `read(rfd, buf, sizeof(buf));`
    4. 读完之后**关闭**文件描述符：`close(rfd)`

    ````c
    #include <fcntl.h>
    #include <sys/stat.h>
    
    int main()
    {
        // 1. 打开管道文件
        // 因为要read管道, so打开方式, 应该指定为 O_RDONLY
        // 如果只打开了读端, 写端还没有打开, open阻塞, 当写端被打开, 阻塞就解除了
        int rfd = open("./testfifo", O_RDONLY);
        if(rfd == -1)
        {
            perror("open");
            exit(0);
        }
        printf("以只读的方式打开文件成功...\n");
    
        // 2. 循环读管道
        while(1)
        {
            char buf[1024];
            memset(buf, 0, sizeof(buf));
            // 读是阻塞的, 如果管道中没有数据, read自动阻塞
            // 有数据解除阻塞, 继续读数据
            int len = read(rfd, buf, sizeof(buf));
            printf("读出的数据: %s\n", buf);
            if(len == 0)
            {
                // 写端关闭了, read解除阻塞返回0
                printf("管道的写端已经关闭, 拜拜...\n");
                break;
            }
    
        }
        close(rfd);
    
        return 0;
    }
    ````

    


​    

## 4. 管道的读写行为

关于管道不管是**有名**的还是**匿名**的，<u>在进行读写的时候，它们表现出的行为是一致的</u>；

下面是对其读写行为的总结:

- **读管道**，需要根据**写端的状态**进行分析：
    - **写端没有关闭** (操作管道写端的**文件描述符没有被关闭**)
        - 如果管道中<u>没有数据 ==> 读阻塞</u> , 如果管道中被写入了数据，阻塞解除（调用read没有数据，直到管道内部出现数据）
        - 如果管道中<u>有数据 ==> 不阻塞</u>，管道中的数据被读完了，再继续读管道还会阻塞
    - **写端已经关闭了** (**没有可用的文件描述符**可以写管道了)
        - 管道中<u>没有数据 ==> 读端解除阻塞</u>，read 函数返回 0（写端虽然关闭，仍调用read，可以再次打开写端口）
        - 管道中<u>有数据 ==> read 先将数据读出，数据读完之后返回 0, 不会阻塞了</u>
- **写管道**，需要根据**读端的状态**进行分析：
    - **读端没有关闭**
        - 如果管道有<u>存储的空间，一直写数据</u>
        - 如果管道<u>写满了，写操作就阻塞，当读端将管道数据读走了，解除阻塞继续写</u>（调用write时管道满了，等到有数据被读走后才能写）
    - **读端关闭了**，<u>管道破裂 (异常), 进程直接退出</u>（读端关闭，调用write，管道就坏了）

管道的两端默认是阻塞的，可以修改为非阻塞：

````c
// 通过fcntl 修改就可以, 一般情况下不建议修改
// 管道操作对应两个文件描述符, 分别是管道的读端 和 写端

// 1. 获取读端的文件描述符的flag属性
int flag = fcntl(fd[0], F_GETFL);
// 2. 添加非阻塞属性到 flag中
flag |= O_NONBLOCK;
// 3. 将新的flag属性设置给读端的文件描述符
fcntl(fd[0], F_SETFL, flag);
// 4. 非阻塞读管道
char buf[4096];
read(fd[0], buf, sizeof(buf));
````

PS：只有在 linux 下的文件才能创建管道
