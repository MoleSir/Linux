# 进程控制

## 1. 进程概述

​	从严格意义上来讲，==程序==和==进程==是两个不同的概念，他们的状态，占用的系统资源都是不同的。

- **程序**：就是磁盘上的**可执行文件的文件**，并且只占用**磁盘上**的空间，是一个静态的概念。

- **进程**：**被执行之后**的程序叫做进程，不占用磁盘空间，需要消耗系统的**内存，CPU资源**，每个运行的进程的都对应一个属于自己的**虚拟地址空间**，这是一个动态的概念。



### 1.1 并行与并发

- **CPU 时间片**

​		CPU 在某个时间点只能处理一个任务，但是操作系统都**支持多任务**的，那么在计算机 CPU 只有一个的情况		下是怎么完成多任务处理的呢？

​		CPU 会给**每个进程**分配一个**时间段**，进程得到这个**时间片**之后才可以运行，使各个程序从表面上看是同时		进行的。如果在时间片结束时进程还在运行，CPU 的使用权将被收回，该进程将会被中断挂起等待下一个时		间片。如果进程在时间片结束前阻塞或结束，则 CPU 当即进行切换，这样就可以避免 CPU 资源的浪费。

​		因此可以得知，在我们使用的计算机中启动的多个程序，从宏观上看是同时运行的，从微观上看由于 CPU 一		次只能处理一个进程，所有它们是轮流执行的，只不过切换速度太快，我们感觉不到罢了，因此 CPU 的核数		越多计算机的处理效率越高。

- **并行与并发**
    - **并行**：
        - 并行的多进程**同时运行**是真实存在的，可以在同一时刻同时运行多个进程

        - 并行需要依赖多个硬件资源，单个是无法实现的。
    - **并发**：
        - 并发的同时运行是一个假象，咖啡机也好 CPU 也好在某一个时间点只能为某一个个体来服务，因此不可能同时处理多任务，这是通过上图的咖啡机 / 计算机的 CPU 快速的**时间片切换**实现的。

        - 并发是针对某一个硬件资源而言的，在某个时间段之内处理的任务的总量，量越大效率越高。



### 1.2 PCB

​	==PCB - 进程控制块（Processing Control Block）==，Linux 内核的进程控制块本质上是一个叫做 `task_struct` 的结构体。在这个结构体中记录了进程运行相关的一些信息，下面介绍一些常用的信息：

- **进程 id**：每一个进程都一个唯一的进程 ID，类型为 `pid_t`, 本质是一个**整形数**

- **进程的状态**：进程有不同的状态，状态是一直在变化的，有**就绪、运行、挂起、停止**等状态。

- 进程对应的**虚拟地址空间**的信息。


- 描述控制**终端**的信息，进程在哪个终端启动默认就和哪个终端绑定。


- 当前**工作目录**：默认情况下，启动进程的目录就是当前的工作目录


- **umask 掩码**：在创建新文件的时候，通过这个掩码屏蔽某些用于对文件的操作权限。

- **文件描述符表**：每个被分配的文件描述符都对应一个已经打开的磁盘文件

- 和**信号**相关的信息：在 Linux 中 调用函数 , 键盘快捷键 , 执行shell命令等操作都会产生信号。

    - **阻塞信号**集：记录当前进程中阻塞哪些已产生的信号，使其不能被处理

    - **未决信号**集：记录在当前进程中产生的哪些信号还没有被处理掉。

- **用户 id 和组 id**：当前进程属于哪个用户，属于哪个用户组

- **会话**（Session）和**进程组**：多个进程的集合叫进程组，多个进程组的集合叫会话。

- 进程可以使用的**资源上限**：可以使用 shell 命令 ulimit -a 查看详细信息。



### 1.3 进程状态

​	进程一共有五种状态分别为：==创建态，就绪态，运行态，阻塞态(挂起态)，退出态(终止态)==

​	其中**创建态**和**退出态**维持的时间是非常短的，稍纵即逝；

​	我们主要是需要将就绪态 , 运行态 , 挂起态，三者之间的状态切换搞明白。

![img](https://subingwen.cn/linux/process/1557237111672.png)

- **就绪态**：万事俱备，只欠东风（CPU资源）
    - 进程被创建出来了，有运行的资格但是还没有运行，需要抢 CPU 时间片
    - 得到 CPU 时间片，进程开始运行，从就*绪态转换为运行态*。
    - 进程的 CPU 时间片用完了，再次失去 CPU, 从*运行态转换为就绪态*。
- **运行态**：获取到 CPU 资源的进程，进程只有在这种状态下才能运行
    - 运行态不会一直持续，进程的 CPU 时间片用完之后，再次失去 CPU，从*运行态转换为就绪态*
    - 只要进程还没有退出，就会在就*绪态和运行*态之间不停的切换。
- **阻塞态**：进程被强制放弃 CPU，并且没有抢夺 CPU 时间片的资格
    - 比如：在程序中调用了某些函数（比如: sleep ()），进程又运行态转换为阻塞态（挂起态）
    - 当某些条件被满足了（比如：slee () 睡醒了），进程的阻塞状态也就被解除了，进程从阻塞态转换为就绪态。
- **退出态**：进程被销毁，占用的系统资源被释放了
    - 任何状态的进程都可以直接转换为退出态。



### 1.4 进程命令

​	在研究如何创建进程之前，先来看一下如何在终端中通过命令完成进程相关的操作：

- **查看进程**

    ````makefile
    $ ps aux
    	- a: 查看所有终端的信息
    	- u: 查看用户相关的信息
    	- x: 显示和终端无关的进程信息
    ````

    ![img](https://subingwen.cn/linux/process/image-20210203171636845.png)

​		如果特别想知道每个参数控制着哪些信息，可以通过 ps a, ps u, ps x 分别查看；

- **杀死进程**

    kill 命令可以发送某个信号到对应的进程，进程收到某些信号之后默认的处理动作就是退出进程;

    如果要给进程发送信号，可以先查看一下 Linux 给我们提供了哪些标准信号。

    ````shell
    $ kill -l
    1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
    6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
    11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
    16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
    21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
    26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
    31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
    38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
    43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
    48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
    53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
    58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
    63) SIGRTMAX-1  64) SIGRTMAX
    ````

    9 号信号（SIGKILL）的行为是**无条件杀死进程**，想要杀死哪个进程就可以把这个**信号发送给这个进程**，操作如下：

    ````shell
    # 无条件杀死进程, 进程ID通过 ps aux 可以查看
    $ kill -9 进程ID
    $ kill -SIGKILL 进程ID
    ````

    



## 2. 进程的创建

### 2.1 进程相关函数

​	Linux 中进程 ID 为 `pid_t` 类型，其本质是一个**正整数**，通过上边的 `ps aux` 命令已经得到了验证。

​	PID 为 1 的进程是 Linux 系统中创建的**第一个进程**。

- **获取当前进程的进程 ID（PID）**

    ````c
    #include <sys/types.h>
    #include <unistd.h>
    pid_t getpid(void);
    ````

- **获取当前进程的父进程 ID（PPID）**

    ````c
    #include <sys/types.h>
    #include <unistd.h>
    pid_t getppid(void);
    ````

- **创建一个新的进程**

    ````c
    #include <unistd.h>
    pid_t fork(void);
    ````

    

### 2.2 fork()

````c
pid_t fork(void);
````

​	启动磁盘上的**应用程序**，得到一个**进程**，如果在这个启动的进程中调用 `fork()` 函数，就会得到一个新的进程，我们习惯将其称之为==子进程==。

> PS 需要包含头文件：
>
> ````c
> #include <unistd.h>
> ````

​	每个进程都对应一个属于自己的**虚拟地址空间**，子进程的地址空间是基于父进程的地址空间**拷贝**出来的，虽然是拷贝但是两个地址空间中存储的信息不可能是完全相同的，下图是拷贝之后父子进程各自的虚拟地址空间：

<img src="https://subingwen.cn/linux/process/image-20210203181255536.png" alt="img" style="zoom: 33%;" />

- **相同点：**

    拷贝完成之后（注意这个**时间点**），两个地址空间中的用户区数据是相同的。用户区数据主要数据包括：

    - 代码区：默认情况下父子进程地址空间中的**源代码始终相同**。
    - 全局数据区：父进程中的全局变量和变量值**全部被拷贝一份**放到了子进程地址空间中
    - 堆区：父进程中的堆区变量和变量值**全部被拷贝一份**放到了子进程地址空间中
    
    - 动态库加载区（内存映射区）：父进程中数据信息被**拷贝一份**放到了子进程地址空间中
    
    - 栈区：父进程中的栈区变量和变量值**全部被拷贝一份**放到了子进程地址空间中
    
    - 环境变量：默认情况下，父子进程地址空间中的环境变量**始终相同**。
    
    - 文件描述符表: 父进程中被分配的文件描述符都会**拷贝**到子进程中，在子进程中**可以使用**它们打开对应的文件。

- **区别：**

    - 父子进程各自的虚拟地址空间是**相互独立**的，不会互相干扰和影响。		
    
    - 父子进程地址空间中代码区代码虽然相同，但是父子进程执行的**代码逻辑可能是不同的**。
    
    - 由于父子进程可能执行不同的代码逻辑，因此地址空间拷贝完成之后，全局数据区 , 栈区 , 堆区 , 动态库加载区(内存映射区) 数据会**各自发生变化**，由于地址空间是**相互独立**的，因此**不会互相覆盖数据**。
    
    - 由于每个进都有自己的**进程 ID**，因此内核区存储的父子进程 ID 是不同的。
    
    - 进程启动之后进入就绪态，运行需要争抢 CPU 时间片而且可能执行不同的业务逻辑，所以父子**进程的状态**可能是不同的。
    
    - `fork ()` 调用成功之后，会**返回两个值**，父子进程的返回值是不同的。
    
        - 该函数调用成功之后，从一个虚拟地址空间变成了两个虚拟地址空间，每个地址空间中都会将 `fork()` 的返回值记录下来，这就是为什么会得到两个返回值的原因。
    
        - 父进程的虚拟地址空间中将该返回值标记为一个大于 0 的数（其实记录的是**子进程的进程 ID**）
    
        - 子进程的虚拟地址空间中将该**返回值标记 0**
    
        - 在程序中需要通过 `fork ()` 的返回值来**判断**当前进程是子进程还是父进程。
    
            ````c
            int main()
            {
                // 在父进程中创建子进程
                pid_t pid = fork();
                printf("当前进程fork()的返回值: %d\n", pid);
                // 父进程的代码与子进程完全相同，但对 fork 的返回值不同；
                // 注意这时已经有了两个进程，内存中有两份相同的代码，父子进程各自根据fork的返回值，在自己
                // 的进程中执行；
                if(pid > 0)
                {
                    // 父进程执行的逻辑
                    printf("我是父进程, pid = %d\n", getpid());
                }
                else if(pid == 0)
                {
                    // 子进程执行的逻辑
                    printf("我是子进程, pid = %d, 我爹是: %d\n", getpid(), getppid());
                }
                else // pid == -1
                {
                    // 创建子进程失败了
                }
            
                // 不加判断, 父子进程都会执行这个循环
                for(int i=0; i<5; ++i)
                {
                    printf("%d\n", i);
                }
            
                return 0;
            }
            ````
    
            



## 3. 父子进程

### 3.1 进程执行位置

​	父进程中成功创建了子进程，子进程就拥有父进程代码区的**所有代码**；

​	那么子进程中的代码是在什么位置开始运行的呢？

​	父进程肯定是从 `main ()` 函数开始运行的，子进程是在父进程中调用` fork ()` 函数之后被创建，子进程就从 `fork ()` 之后开始向下执行代码。

![img](https://subingwen.cn/linux/process/image-20210203210603208.png)

​	上图中演示了父子进程中代码的**执行流程**，可以看到如果在程序中对 `fork()` 的返回值做了判断，就可以控制父子进程的行为，如果没有做任何判断这个代码块父子进程都可以执行。

​	在编写多进程程序的时候，一定要将代码想象成**多份**进行分析，因为直观上看代码就一份，但实际上数据都是多份，并且多份数据中变量名都相同，但是他们的值却不一定相同。



### 3.2 循环创建子进程

​	掌握了进程创建函数之后，实现一个简单的功能，在一个父进程中循环创建 3 个子进程，也就是最后需要得到 4 个进程，1 个父进程，3 个子进程，为了方便验证程序的正确性，要求在程序中打印出每个进程的进程 ID。

​	下面是编写的代码：

````c
// process_loop.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main()
{
    for (int i = 0; i < 3; i++)
    {
        pid_t pid = fork();
        printf("current process id: %d\n", getpid());
    }

    return 0;
}
````

​	编译并执行上面的代码，得到了如下结果：

````shell
current process id: 77
current process id: 78
current process id: 77
current process id: 79
current process id: 78
current process id: 80
current process id: 77
current process id: 81
current process id: 80
current process id: 83
current process id: 78
current process id: 79
current process id: 84
current process id: 82
````

​	通过程序打印的信息发现程序循环了三次，最终得到了 8 个进程，也就是创建出了 7 个子进程，还是上面跟大家讲的那句话，对应多进程的程序，一定要代码分成很多份去分析，并且如果没有在程序中加条件控制，所有的代码父子进程都是有资格执行的。接下来分析上边的编写的代码，通过画图的方式分析为什么得到了 7 个子进程：

<img src="https://subingwen.cn/linux/process/image-20191229121508802.png" alt="img" style="zoom:50%;" />

上图中的树状结构，蓝色节点代表父进程：

- 循环第一次 i = 0，创建出一个子进程，即红色节点，子进程变量值来自父进程拷贝，因此 i=0

- 循环第二次 i = 1，蓝色父进程和红色子进程都去创建子进程，得到两个紫色进程，子进程变量值来自父进程拷贝，因此 i=1
- 循环第三次 i = 2，蓝色父进程和红色、紫色子进程都去创建子进程，因此得到 4 个绿色子进程，子进程变量值来自父进程拷贝，因此 i=2
- 循环第三次 i = 3，所有进程都不满足条件 for(int i=0; i<3; ++i) 因此不进入循环，退出了。

---

​	通过上面的分析，最终得到解决方案，我们可以只让父进程创建子进程，如果是子进程不让其继续创建子进程，因此只需要在程序中添加关于父子进程的判断即可。

​	修改之后的代码如下：

````c
#include <stdio.h>
#include <unistd.h>

int main()
{
    pid_t pid;
    for(int i = 0; i < 3; i++)
    {
        pid = fork();
        if (pid == 0)
            break;
    }
    printf("current process id: %d\n", getpid());
    return 0;
}
````

​	最后编译并执行程序，查看最终结果，可以看到最后确实得到了 4 个不同的进程，pid 最小的为父进程，其余为子进程：

````shell
current process id: 98
current process id: 99
current process id: 97
current process id: 100
````

​	在多进程序中，进程的执行顺序是没有规律的，因为所有的进程都需要在就绪态争抢CPU时间片，抢到了就执行，抢不到就不执行，但是不用担心，默认进程的优先级是相同的，操作系统不会让某一个进程一直抢不到CPU时间片。



### 3.3 终端显示问题

​	在执行多进程程序的时候，经常会遇到下图中的问题，看似进程还没有执行完成，貌似是因为什么原因被阻塞了，实际上终端是正常的，当我们通过键盘输入一些命令，终端也能接受输入并且输出相关信息，那么为什么终端会显示成这个样子呢？

<img src="https://subingwen.cn/linux/process/image-20210203215938828.png" alt="img" style="zoom:50%;" />

- `a.out` 进程启动之后，共创建了 3 个子进程，其实 `a.out` 也是有父进程的就是当前的终端

- 终端只能检测到 `a.out` 进程的状态，`a.out ` 执行期间终端切换到后台，`a.out` 执行完毕之后终端切换回前台

- 当终端切换到前之后，`a.out` 的子进程**还没有执行完毕**，当子进程输出的信息就显示到终端命令提示符的后边了，导致终端显示有问题，但是此时终端是可以接收键盘输入的，只是看起来不美观而已。


- 想要解决这个问题，需要*让所有子进程退出之后再退出父进程*，比如：在父进程代码中调用 sleep ()

    ````c
    pid_t pid = fork();
    if(pid > 0)
    {
        sleep(3);	// 让父进程睡一会儿
    }
    else if(pid == 0)
    {
        // 子进程
    }
    ````

    



## 4. execl 和 execlp 函数

​	在项目开发过程中，有时候有这种需求，需要通过现在运行的进程启动磁盘上的**另一个可执行程序**，也就是*通过一个进程启动另一个进程*，这种情况下我们可以使用 `exec` 族函数，函数原型如下：

````c
#include <unistd.h>

extern char **environ;
int execl(const char *path, const char *arg, ...
          /* (char  *) NULL */);
int execlp(const char *file, const char *arg, ...
           /* (char  *) NULL */);
int execle(const char *path, const char *arg, ...
           /*, (char *) NULL, char * const envp[] */);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],
            char *const envp[]);
````

​	这些函数执行成功后**不会返回**，因为调用进程的实体，包括代码段，数据段和堆栈等都**已经被新的内容取代**（也就是说用户区数据基本**全部被替换掉**了），只留下进程 ID 等一些表面上的信息仍保持原样，颇有些神似” 三十六计” 中的” 金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有**调用失败**了，它们才会返回一个 -1，从原程序的调用点接着往下执行。

---

​	也就是说 `exec` 族函数**并没有创建新进程的能力**，只是有大无畏的牺牲精神，让起启动的新进程寄生到自己虚拟地址空间之内，*并挖空了自己的地址空间用户区，把新启动的进程数据填充进去*。

---

​	`exec` 族函数中最常用的有两个 `execl()` 和 `execlp()`，这两个函数是对其他 4 个函数做了进一步的封装，下面介绍一下。



### 4.1 execl()

​	该函数可用于执行**任意一个可执行程序**，函数需要通过**指定的文件路径**才能找到这个可执行程序。

````c
#include <unistd.h>
// 变参函数
int execl(const char *path, const char *arg, ...);
````

- **参数:**
    - `path`: 要启动的可执行程序的**路径**，推荐使用**绝对路径**
    - `arg`: `ps aux` 查看进程的时候，启动的**进程的名字**，可以**随意指定**，一般和要启动的可执行程序名**相同**
    - ... : 要执行的命令需要的参数，可以写**多个**，最后以 `NULL` 结尾，表示参数**指定完了**。
- **返回值**：如果这个函数**执行成功**，没有**返回值**，如果执行失败，返回 -1



### 4.2 execlp()

​	该函数常用于**执行已经设置了环境变量的可执行程序**，函数中的 `p `就是 `path`，也是说这个函数会自动搜索系统的环境变量 `PATH`，因此使用这个函数执行可执行程序**不需要指定路径**，只需要指定出名字即可。

​	（跟 execl 就差个路径）

````c
// p == path
int execlp(const char *file, const char *arg, ...);
````

- **参数:**
    - `file`: 可执行程序的名字
    - 在环境变量 `PATH` 中，可执行程序可以**不加路径**
    - 没有在环境变量 `PATH` 中，可执行程序需要指定绝对路径
    - `arg`：`ps aux` 查看进程的时候，启动的进程的名字，可以随意指定，一般和要启动的可执行程序名相同
    - ... : 要执行的命令需要的参数，可以写多个，最后以 `NULL` 结尾，表示参数**指定完了**。
- **返回值**：如果这个函数**执行成功**，没有**返回值**，如果执行失败，返回 -1



### 4.3 函数的使用

​	关于 `exec` 族函数，我们一般**不会**在进程中**直接调用**，如果直接调用这个进程的代码区代码被替换也就不能按照原来的流程工作了。

​	我们一般在调用这些函数的时候都会**先创建一个子进程**，在子进程中**调用 `exec` 族函数**，子进程的用户区数据被替换掉开始执行新的程序中的代码逻辑，但是父进程<u>不受任何影响仍然可以继续正常工作</u>。

​	`execl () ` 或者 `execlp ()` 函数的使用方法如下:

````c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{   
    // 创建新进程
    pid_t pid = fork();
    // 进入子进程
    if (pid == 0)
    {
        // 磁盘上的 /bin/ps
#if 1
        execl("/bin/ps", "title", "aux", NULL);
#else
        execlp("ps", "title", "aux", NULL);
#endif
        // 如果成功当前子进程的代码区别 ps中的代码区代码替换
        // 下面的所有代码都不会执行
        // 如果函数调用失败了,才会继续执行下面的代码
        perror("execl");
        printf("++++++++++++++++++++++++\n");
        printf("++++++++++++++++++++++++\n");
        printf("++++++++++++++++++++++++\n");
        printf("++++++++++++++++++++++++\n");
        printf("++++++++++++++++++++++++\n");
        printf("++++++++++++++++++++++++\n");
    }
    else if (pid > 0)
    {
         printf("我是父进程.....\n");
    }
    
    return 0;
}
````

````shell
molesir@LAPTOP-FQ8PDMKL:~/linux/第3章进程和线程/source_code/fork$ make rexecl
我是父进程.....
molesir@LAPTOP-FQ8PDMKL:~/linux/第3章进程和线程/source_code/fork$ USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0   8940   332 ?        Ssl  22:47   0:00 /init
root         8  0.0  0.0   8940   228 tty1     Ss   22:47   0:00 /init
molesir      9  0.0  0.0  18344  4020 tty1     S    22:47   0:00 -bash
molesir    117  0.0  0.0  18660  1900 tty1     R    23:25   0:00 title aux
````

​	在子进程中调用 ps aux，并且将这个进程命名为 title；

​	可以看到呈现执行后，自动执行了 ps aux，并且出现了 title 这个进程；



## 5. 进程控制

​	**进程控制**主要是指进程的==退出== , 进程的==回收==和进程的==特殊状态==：==孤儿进程==和==僵尸进程==。



### 5.1 结束进程

​	如果想要直接退出某个进程可以在程序的任何位置调用 exit() 或者_exit() 函数。函数的参数相当于退出码，如果参数值为 0 程序退出之后的状态码就是 0, 如果是 100 退出的状态码就是 100。

````c
// 专门退出进程的函数, 在任何位置调用都可以
// 标准C库函数
#include <stdlib.h>
void exit(int status);

// Linux的系统函数
// 可以这么理解, 在linux中 exit() 函数 封装了 _exit()
#include <unistd.h>
void _exit(int status);
````

​	在 main 函数中直接使用 return 也可以退出进程；



### 5.2 孤儿进程

​	在一个启动的进程中**创建子进程**，这时候父子进程同时运行，但是**父进程**由于某种原因**先退出**了，子进程还在运行，这时候这个子进程就可以被称之为==孤儿进程==（跟现实是一样的）。

​	操作系统是非常关爱运行的每一个进程的，当检测到某一个进程变成了孤儿进程，这时候系统中就会有<u>一个固定的进程领养这个孤儿进程</u>。

​	如果使用 Linux **没有桌面终端**，这个领养孤儿进程的进程就是 **`init` 进程**（PID=1），如果**有桌面终端**，这个领养孤儿进程就是桌面进程。

​	那么问题来了，系统为什么要领养这个孤儿进程呢？在子进程退出的时候, <u>进程中的**用户区**可以自己释放, 但是进程内核区的`pcb`资源自己无法释放，必须要由父进程来释放子进程的`pcb`资源</u>，孤儿进程被领养之后，这件事儿干爹就可以代劳了，这样可以**避免系统资源的浪费**。

​	下面这段代码就可以得到一个孤儿进程：

````c
int main()
{
    // 创建子进程
    pid_t pid = fork();

    // 父进程
    if(pid > 0)
    {
        printf("我是父进程, pid=%d\n", getpid());
    }
    else if(pid == 0)
    {
        sleep(1);	// 强迫子进程睡眠1s, 这个期间, 父进程退出, 当前进程变成了孤儿进程
        // 子进程
        printf("我是子进程, pid=%d, 父进程ID: %d\n", getpid(), getppid());
    }
    return 0;
}
````

​	执行结果：

````shell
我是父进程, pid=169
我是子进程, pid=170, 父进程ID: 1
````

​	显然，此时父进程不再是 169 而是 1 号进程；



### 5.3 僵尸进程

​	在一个启动的进程中**创建子进程**，这时候就有了**父子两个进程**，父进程正常运行，<u>子进程先与父进程结束，子进程无法释放自己的 PCB 资源，需要父进程来做这个件事儿，但是如果父进程也不管</u>，这时候子进程就变成了==僵尸进程==。

​	孤儿进程是子进程还在运行，但是父进程已经结束；而僵尸进程是子进程死亡，但父进程没有释放其 PCB；

---

​	**僵尸进程**不能将它看成是一个正常的进程，这个进程已经死亡了，用户区资源已经被释放了，只是还占用着一些内核资源（PCB）。 僵尸进程就相当于是一副已经腐烂只剩下骨头的尸体。

​	**僵尸进程**的出现是由于<u>这个已死亡的进程的父进程不作为造成的</u>。

---

​	运行下面的代码就可以得到一个僵尸进程了：

````c
int main()
{
    pid_t pid;
    // 创建子进程
    for(int i=0; i<5; ++i)
    {
        pid = fork();
        if(pid == 0)
        {
            break;
        }
    }

    // 父进程
    if(pid > 0)
    {
        // 需要保证父进程一直在运行
        // 一直运行不退出, 并且也做回收, 就会出现僵尸进程
        while(1)
        {
            printf("我是父进程, pid=%d\n", getpid());
            sleep(1);
        }
    }
    else if(pid == 0)
    {
        // 子进程, 执行这句代码之后, 子进程退出了
        printf("我是子进程, pid=%d, 父进程ID: %d\n", getpid(), getppid());
    }
    return 0;
}
````

````shell
# ps aux 查看进程信息
# Z+ --> 这个进程是僵尸进程, defunct, 表示进程已经死亡
robin     22598  0.0  0.0   4352   624 pts/2    S+   10:11   0:00 ./app
robin     22599  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] <defunct> # 子进程
robin     22600  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] <defunct> # 子进程
robin     22601  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] <defunct> # 子进程
robin     22602  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] <defunct> # 子进程
robin     22603  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] <defunct> # 子进程
````

---

​	消灭**僵尸进程**的方法是，<u>杀死这个僵尸进程的父进程</u>，这样僵尸进程的资源就**被系统回收**了。

​	通过 `kill -9 僵尸进程 PID` 的方式是不能消灭僵尸进程的，这个命令**只对活着的进程有效**，僵尸进程已经死了，鞭尸是不能解决问题的。

---



### 5.4 进程回收

​	为了避免僵尸进程的产生，一般我们会在父进程中进行子进程的资源回收;

​	回收方式有两种，一种是阻塞方式 `wait()`，一种是非阻塞方式 `waitpid()`。

#### 5.4.1 wait

​	这是个**阻塞函数**，<u>如果没有子进程退出，函数会一直阻塞等待，当检测到子进程退出了，该函数阻塞解除回收子进程资源</u>。

​	这个函数被**调用一次**，只能**回收一个**子进程的资源，如果有**多个子进程**需要资源回收，函数需要被调用**多次**。

​	函数原型如下：

````c
// man 2 wait
#include <sys/wait.h>

pid_t wait(int *status);
````

- **参数**：<u>传出参数，通过传递出的信息判断回收的进程是怎么退出的</u>，如果不需要该信息可以指定为 `NULL`。取出整形变量中的数据需要使用一些==宏函数==，具体操作方式如下：
    - `WIFEXITED(status)`: 返回 1, 进程是**正常退出**的
    - `WEXITSTATUS(status)`：得到进程退出时候的**状态码**，相当于 `return` 后边的数值，或者 `exit ()` 函数的参数
    - `WIFSIGNALED(status)`: 返回 1, 进程是**被信号杀死**了
    - `WTERMSIG(status)`: 获得进程是被**哪个信号杀死**的，会得到信号的**编号**
- **返回值:**
    - 成功：返回被回收的**子进程的进程 ID**
    - 失败: -1
        - 没有子进程资源可以回收了，函数的<u>阻塞会自动解除</u>，返回 - 1
        - 回收子进程资源的时候出现了**异常**


​	下面代码演示了如何通过 `wait()` 回收多个子进程资源：

````c
// wait 函数回收子进程资源
#include <sys/wait.h>

int main()
{
    pid_t pid;
    // 创建子进程
    for(int i=0; i<5; ++i)
    {
        pid = fork();
        if(pid == 0)
        {
            break;
        }
    }

    // 父进程
    if(pid > 0)
    {
        // 需要保证父进程一直在运行
        while(1)
        {
            // 回收子进程的资源
            // 子进程由多个, 需要循环回收子进程资源
            pid_t ret = wait(NULL);
            if(ret > 0)
            {
                printf("成功回收了子进程资源, 子进程PID: %d\n", ret);
            }
            else
            {
                printf("回收失败, 或者是已经没有子进程了...\n");
                break;
            }
            printf("我是父进程, pid=%d\n", getpid());
        }
    }
    else if(pid == 0)
    {
        // 子进程, 执行这句代码之后, 子进程退出了
        printf("我是子进程, pid=%d, 父进程ID: %d\n", getpid(), getppid());
    }
    return 0;
}
````

​	这样当父进程回收完所有的子进程后就可以退出；



#### 5.4.2 waitpid

​	`waitpid ()` 函数可以看做是 `wait ()` 函数的**升级版**，通过该函数可以<u>控制回收子进程资源的方式是**阻塞**还是**非阻塞**</u>，另外还可以通过该函数进行**精准打击**，可以精确**指定**回收某个或者某一类或者是全部子进程资源。

​	该函数函数原型如下：

````c
// man 2 waitpid
#include <sys/wait.h>
// 这个函数可以设置阻塞, 也可以设置为非阻塞
// 这个函数可以指定回收哪些子进程的资源
pid_t waitpid(pid_t pid, int *status, int options);
````

- **参数:**

- `pid`：指定回收进程

    - -1：**回收所有的子进程资源**，和 `wait ()` 是一样的，<u>无差别回收，并不是一次性就可以回收多个，也是需要循环回收的</u>

    - 大于0：**指定**回收某一个进程的资源 ，pid 是要回收的子进程的**进程 ID**

    - 0：回收当前进程组的**所有子进程 ID**

    - 小于 -1：pid 的**绝对值**代表**进程组 ID**，表示要回收这个**进程组的所有子进程资源**

- `status`: `NULL`, 和 `wait` 的参数是一样的

- `options`: 控制函数是**阻塞**还是**非阻塞**

    - 0: 函数是行为是**阻塞**的 ==> 和 wait 一样

    - `WNOHANG`: 函数是行为是**非阻塞**的

- **返回值:**

    - 如果函数是非阻塞的，并且子进程还在运行，返回 0

    - 成功：得到子进程的进程 ID

    - 失败: -1

        - 没有子进程资源可以回收了，函数如果是阻塞的，阻塞会解除，直接返回 - 1

        - 回收子进程资源的时候出现了异常

---

​	下面代码演示了如何通过 `waitpid()` **阻塞回收多个子进程资源**：

````c
// 和wait() 行为一样, 阻塞
#include <sys/wait.h>

int main()
{
    pid_t pid;
    // 创建子进程
    for(int i=0; i<5; ++i)
    {
        pid = fork();
        if(pid == 0)
        {
            break;
        }
    }

    // 父进程
    if(pid > 0)
    {
        // 需要保证父进程一直在运行
        while(1)
        {
            // 回收子进程的资源
            // 子进程由多个, 需要循环回收子进程资源
            int status;
            pid_t ret = waitpid(-1, &status, 0);  // == wait(NULL);
            if(ret > 0)
            {
                printf("成功回收了子进程资源, 子进程PID: %d\n", ret);
                                // 判断进程是不是正常退出
                if(WIFEXITED(status))
                {
                    printf("子进程退出时候的状态码: %d\n", WEXITSTATUS(status));
                }
                if(WIFSIGNALED(status))
                {
                    printf("子进程是被这个信号杀死的: %d\n", WTERMSIG(status));
                }
            }
            else
            {
                printf("回收失败, 或者是已经没有子进程了...\n");
                break;
            }
            printf("我是父进程, pid=%d\n", getpid());
        }
    }
    else if(pid == 0)
    {
        // 子进程, 执行这句代码之后, 子进程退出了
        printf("===我是子进程, pid=%d, 父进程ID: %d\n", getpid(), getppid());
    }
    return 0;
}
````

​	下面代码演示了如何通过 waitpid() 非阻塞回收多个子进程资源：

````c
// 非阻塞处理
#include <sys/wait.h>

int main()
{
    pid_t pid;
    // 创建子进程
    for(int i=0; i<5; ++i)
    {
        pid = fork();
        if(pid == 0)
        {
            break;
        }
    }

    // 父进程
    if(pid > 0)
    {
        // 需要保证父进程一直在运行
        while(1)
        {
            // 回收子进程的资源
            // 子进程由多个, 需要循环回收子进程资源
            // 子进程退出了就回收, 
            // 没退出就不回收, 返回0
            int status;
            pid_t ret = waitpid(-1, &status, WNOHANG);  // 非阻塞
            if(ret > 0)
            {
                printf("成功回收了子进程资源, 子进程PID: %d\n", ret);
                // 判断进程是不是正常退出
                if(WIFEXITED(status))
                {
                    printf("子进程退出时候的状态码: %d\n", WEXITSTATUS(status));
                }
                if(WIFSIGNALED(status))
                {
                    printf("子进程是被这个信号杀死的: %d\n", WTERMSIG(status));
                }
            }
            else if(ret == 0)
            {
                printf("子进程还没有退出, 不做任何处理...\n");
            }
            else
            {
                printf("回收失败, 或者是已经没有子进程了...\n");
                break;
            }
            printf("我是父进程, pid=%d\n", getpid());
        }
    }
    else if(pid == 0)
    {
        // 子进程, 执行这句代码之后, 子进程退出了
        printf("===我是子进程, pid=%d, 父进程ID: %d\n", getpid(), getppid());
    }
    return 0;
}
````

