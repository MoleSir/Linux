# 文件描述符

## 1. 虚拟地址空间

==虚拟地址空间==是一个抽象的概念：

- 可以用来加载程序数据（数据可能被加载到物理内存上，空间不够就加载到虚拟内存中）；
- 对应着一段连续的内存地址，起始位置为 0；
- 虚拟是因为这个起始的 0 地址是被虚拟出来的， 不是物理内存的 0 地址。

虚拟地址空间的大小由操作系统决定：

32位的操作系统虚拟地址空间的大小为 2^32 字节，也就是 4G；

64 位的操作系统虚拟地址空间大小为 2^64 字节。

运行磁盘上一个**可执行程序**, 就会得到一个**进程**，内核会给每一个运行的进程创建一块**属于自己的虚拟地址空间**，并将应用程序数据装载到虚拟地址空间对应的地址上。

进程在运行过程中，程序内部所有的指令都是通过 **CPU** 处理完成的；

CPU 只进行数据运算并不具备数据存储的能力，其处理的数据都**加载自物理内存**；

数据通过 CPU 中的内存管理单元==MMU（Memory Management Unit）==从进程的**虚拟地址空间**中映射到**物理地址空间**；

​	<img src="https://subingwen.cn/linux/file-descriptor/image-20210130092825532.png" alt="img" style="zoom:50%;" />

### 1.1 存在的意义

直接使用物理内存的的缺陷：

- **每个进程的地址不隔离，有安全风险：**

    由于程序都是直接访问物理内存，所以恶意程序可以通过内存寻址随意修改别的进程对应的内存数据，以达到破坏的目的。虽然有些时候是非恶意的，但是有些存在 bug 的程序可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。

- **内存效率低：**

    如果直接使用物理内存的话，一个进程对应的内存块就是作为一个整体操作的，如果出现物理内存不够用的时候，我们一般的办法是将不常用的进程拷贝到磁盘的交换分区（虚拟内存）中，以便腾出内存，因此就需要将整个进程一起拷走，如果数据量大，在内存和磁盘之间拷贝时间就会很长，效率低下。

- **进程中数据的地址不确定，每次都会发生变化：**

    由于物理内存的使用情况一直在动态的变化，我们无法确定内存现在使用到哪里了，如果直接将程序数据加载到物理内存，内存中每次存储数据的起始地址都是不一样的，这样数据的加载都需要使用相对地址，加载效率低（静态库是使用绝对地址加载的）。

虚拟地址空间就是一个**中间层**，相当于在程序和物理内存之间设置了一个**屏障**，将二者**隔离**开来；

程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由**操作系统**将这个**虚拟地址映射到适当的物理内存地址**上；

这样，只要**操作系统**处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到**内存地址空间隔离**的效果。

### 1.2 分区

从**操作系统层级**上看，虚拟地址空间（每个进程都有一个虚拟地址空间，它们都认为自己独显 CUP 与内存）主要分为两个部分==内核区==和==用户区==。

内核区：
- 内核空间为**内核保留**，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数；
- 内核总是驻留在内存中，是操作系统的一部分；
- 系统中所有进程对应的虚拟地址空间的内核区都会映射到同一块物理内存上（每个进程有各种的虚拟地址空间，这些空间对于真实物理地址的映射是由操作系统分配，两个不同进程的相同虚拟地址对应的不一定是同一个物理地址，但对不同进程虚拟地址空间中内核区的代码与数据，都会被操作系统映射到相同的一份物理地址，这样在真实物理内存中，只要加载一份内核的代码就可以给所有的进程使用）；

用户区：
- 存储用户程序运行中用到的各种数据；

下图为一个虚拟地址空间的分布（32位操作系统）：

<img src="https://subingwen.cn/linux/file-descriptor/image-20210130093015907.png" alt="img" style="zoom:50%;" />

进程的虚拟地址空间**从 0 地址**开始；

在程序中打印的变量地址在**虚拟地址空间中的地址**，程序是无法直接访问物理内存的；

虚拟地址空间中**用户区**地址范围是 **0~3G**，里边分为多个区块：

- **保留区：** 位于虚拟地址空间的最底部，未赋予物理地址。任何对它的引用都是非法的，程序中的空指针（NULL）指向的就是这块内存地址。
- **.text段：** ==代码段==也称正文段或文本段，通常用于存放程序的**执行代码** (即 CPU 执行的**机器指令**)，代码段一般情况下是**只读**的，这是对执行代码的一种保护机制。
- **.data段：** ==数据段==通常用于存放程序中**已初始化且初值不为 0 的全局变量和静态变量**。数据段属于静态内存分配 (静态存储区)，**可读可写**。
- **.bss段：** **未初始化以及初始为 0 的全局变量和静态变量**，操作系统会将这些未初始化变量初始化为 0。
- **堆(heap)：**==堆==用于存放进程运行时动态分配的内存：
    - 堆中内容是匿名的，不能按名字直接访问，只能通过指针**间接访问**；
    - 堆向**高地址扩展** (即 “向上生长”)，是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，链表需要多余的数据互相链接，而链表从低地址向高地址遍历。
- **内存映射区(mmap)：**作为==内存映射区==加载磁盘文件，或者加载程序运作过程中需要调用的**动态库**。
- **栈(stack)：** 存储**函数内部**声明的**非静态局部变量，函数参数，函数返回地址等**信息，栈内存由编译器自动分配释放。栈和堆相反地址 “**向下生长**”，分配的内存是**连续**的。
- **命令行参数：**存储进程执行的时候传递给 `main()` 函数的参数，`argc，argv []`。
- **环境变量：** 存储和进程相关的环境变量，比如：工作路径，进程所有者等信息。



## 2.文件描述符

### 2.1 文件描述符

在 **Linux 操作系统**中的一切都被抽象成了文件；

使用==文件描述符（file descriptor，简称fd）==将一个打开的文件与应用程序进行对应；

当在进程中打开一个现有文件或者创建一个新文件时，**内核**向该**进程**返回一个**文件描述符**，用于对应这个打开/新建的文件；

这些**文件描述符**都存储在内核为**每个进程**维护的一个==文件描述符表==中（每个进程都有一张文件描述符表）。

在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。

在 **Linux 系统**中一切皆文件，系统中一切都被抽象成了文件；

对这些文件的读写都需要通过文件描述符来完成；

标准 C 库的文件 IO 函数使用的文件指针 FILE* 在 Linux 中也需要通过文件描述符的辅助才能完成读写操作；

FILE 其实是一个结构体，其内部有一个成员就是文件描述符（下面结构体的第 25 行）：

````c
// linux c FILE结构体定义： /usr/include/libio.h
struct _IO_FILE {
  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */
#define _IO_file_flags _flags
 
  /* The following pointers correspond to the C++ streambuf protocol. */
  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
  char* _IO_read_ptr;	/* Current read pointer */
  char* _IO_read_end;	/* End of get area. */
  char* _IO_read_base;	/* Start of putback+get area. */
  char* _IO_write_base;	/* Start of put area. */
  char* _IO_write_ptr;	/* Current put pointer. */
  char* _IO_write_end;	/* End of put area. */
  char* _IO_buf_base;	/* Start of reserve area. */
  char* _IO_buf_end;	/* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */
 
  struct _IO_marker *_markers;
 
  struct _IO_FILE *_chain;
 
  int _fileno;			// 文件描述符
#if 0
  int _blksize;
#else
  int _flags2;
#endif
  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */
 
#define __HAVE_COLUMN /* temporary */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
 
  /*  char* _save_gptr;  char* _save_egptr; */
 
  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};

// 在文件: /usr/include/stdio.h
typedef struct _IO_FILE FILE;
````

### 2.2 文件描述符表

启动一个进程就会得到一个对应的虚拟地址空间；

这个虚拟地址空间分为两大部分：用户区与内核区，在内核区（每个进程的内核区都指向同一份物理地址）有专门**用于进程管理的模块**；

Linux 的==进程控制块PCB（process control block）==本质是一个叫做 task_struct 的结构体（每个进程就是一个结构体对象）；

里边包括管理进程所需的各种信息，其中有一个结构体叫做 **file** ，叫做**文件描述符表**，里边有一个**整形索引表**，用于存储**文件描述符**。

内核为每一个进程维护了一个文件描述符表，索引表中的值都是从 0 开始的，所以在不同的进程中看到相同的文件描述符，但是它们指向的不一定是同一个磁盘文件。

<img src="https://subingwen.cn/linux/file-descriptor/image-20210130123339157.png" alt="img" style="zoom: 50%;" />




​	Linux 中用户操作的每个**终端**都被视作一个设备文件，当前操作的终端文件可以使用 /dev/tty 表示；

- **打开的最大文件数**

    每一个进程对应的文件描述符表能够存储的打开的**文件数是有限制的**，默认为 1024 个，可以修改的，支持打开的最大文件数据取决于操作系统的硬件配置。

- **默认分配的文件描述符**

    当一个进程被启动之后，内核 PCB 的文件描述符表中就已经分配了**三个文件描述符**（如上图）；

    这三个文件描述符对应的都是当前启动这个进程的**终端文件**（Linux 中一切皆文件，终端就是一个设备文件，在 /dev 目录中）

    - ==STDIN_FILENO==：**标准输入**，可以通过这个文件描述符将数据**输入到终端**文件中，宏值为 0；
    - ==STDOUT_FILENO==：**标准输出**，可以通过这个文件描述符将数据**通过终端输出**出来，宏值为 1；
    - ==STDERR_FILENO==：**标准错误**，可以通过这个文件描述符将**错误信息通过终端输出**出来，宏值为 2；

    这三个默认分配的文件描述符是可以**通过 close() 函数关闭掉**，但是关闭之后当前进程也就不能和当前终端进行输入或者输出的信息交互了。

- **给新打开的文件分配文件描述符**

    - 因为进程启动之后，文件描述符表中的 0,1,2 就被分配出去了，因此从 3 开始分配；
    - 在进程中每打开一个文件，就会给这个文件分配一个新的文件描述符，比如：
        - 通过 open() 函数打开 /hello.txt，文件描述符 3 被分配给了这个文件，保持这个打开状态，再次通过 open() 函数打开 /hello.txt，文件描述符 4 被分配给了这个文件，也就是说一个进程中不同的文件描述符打开的磁盘文件可能是同一个；
        - 通过 open() 函数打开 /hello.txt，文件描述符 3 被分配给了这个文件，将打开的文件关闭，此时文件描述符 3 就被释放了。再次通过 open() 函数打开 /hello.txt，文件描述符 3 被分配给了这个文件，也就是说打开的新文件会关联文件描述符表中**最小的没有被占用**的文件描述符。



## 3. 总结

1. 每个进程对应的文件描述符表默认支持打开的最大文件数为 1024，可以修改；

2. 每个进程的文件描述符表中都已经默认分配了三个文件描述符，对应的都是当前终端文件（/dev/tty）；
3. 每打开新的文件，内核会从进程的文件描述符表中找到一个空闲的没有别占用的文件描述符与其进行关联；
4. 文件描述符表中不同的文件描述符可以对应同一个磁盘文件；
5. 每个进程文件描述符表中的文件描述符值是唯一的，不会重复；







