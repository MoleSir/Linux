# 设置寄存器

接下来，继续执行 go 标签：

````assembly
go:
	mov ax, cs
	mov ds, ax
	mov es, ax
	mov ss, ax
	mov sp, #0xFF00
````

cs 寄存器（code segment）表示代码段寄存器，CPU 当前正在执行的代码在内存中的位置，就是 由 cs:ip 这组寄存器配合指向的，其中 cs 是基地址，ip 是偏移地址；

由于刚刚执行了 ：

```assembly
jmip go, 0x9000
```

所以此时 cs 寄存器的值就是 0x9000，ip 寄存器的值就是 go 标签的偏移地址。

所以上述代码使得：

- ax、ds、es、ss 寄存器的值都变为 0x9000；
- sp 寄存器的值为 0xFF00

ds 寄存器（date segment）说过是数据段寄存器，之前的数据在 0x7c00 处所以其是 0x07c0，现在启动代码被复制到 0x90000，那么 ds 寄存器自然也应该被设置为 0x9000；

es 是扩展段寄存器，不重要；

ss 是栈段寄存器，后面要配合栈基地址寄存器 sp 来表示此时的栈顶地址。而 sp 寄存器现在是 0xFF00，所以此时的栈顶位置 ss:sp 所指向的地址就是 ss << 4 + 0xFF00 = 0x90000 + 0xFF00 = 0x9FF00；

执行完毕得到以下内存布局：

<img src="./pics/3-设置寄存器.assets/640 (3).png" alt="640 (3)" style="zoom:67%;" />



# 回顾

至此，操作系统的最基础的准备工作完成：

1. 启动代码从硬盘移到内存的 0x7c00 处，又被复制到 0x90000 处；
2. 数据段寄存器 ds 和代码段寄存器 cs 此时设置为 0x9000，为跳转代码与访问内存数据，奠定了一个内存基地址；
3. 栈段寄存器 ss 为 0x9000，栈基址寄存器 sp 为 0xFF00。栈顶地址被设置为 0x9FF00；

总的来说就是把 代码段寄存器 cs，数据段寄存器 ds，栈段寄存器 ss 和栈基址寄存器 sp 分别设置好值；给如何访问代码，如何访问数据，如何访问栈进行了一内存的初步规划；

<img src="./pics/3-设置寄存器.assets/640 (4)-16606154855121.png" alt="640 (4)" style="zoom:67%;" />