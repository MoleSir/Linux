# Makefile

​	使用 GCC 的命令行进行程序编译在单个文件下是比较方便的，当工程中的文件逐渐增多，甚至变得十分庞大的时候，使用 GCC 命令编译就会变得力不从心。这种情况下我们需要借助项目构造工具 make 帮助我们完成这个艰巨的任务。==make== 是一个命令工具，是一个解释 ==makefile== 中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如：Visual C++ 的 nmake，QtCreator 的 qmake 等。

​	make 工具在构造项目的时候需要加载一个叫做 **makefile** 的文件，makefile 关系到了整个工程的**编译规则**。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile 定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile 就像一个 Shell 脚本一样，其中**也可以执行操作系统的命令**。

​	makefile 带来的好处就是 ——“**自动化编译**”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。

​	makefile 文件有两种命名方式 **makefile 和 Makefile**，构建项目的时候在哪个目录下执行构建命令 make 这个目录下的 makefile 文件就会别加载，因此在一个项目中可以有多个 makefile 文件，分别位于不同的项目目录中。



## 1. 规则

Makefile 的框架是由**规则**构成的；

make 命令执行时先在 Makefile 文件中**查找各种规则**，对各种规则进行**解析**后**运行**规则。规则的基本格式为：

````makefile
# 每条规则的语法格式:
target1,target2...: depend1, depend2, ...
	command
	......
	......
````

每条规则由三个部分组成分别是目标(target), 依赖(depend) 和命令(command)。

- **命令(command)**: 当前这条规则的==动作==，一般情况下这个动作**就是一个 shell 命令**

    - 例如：通过某个命令编译文件、生成库文件、进入目录等。


    - 动作可以是多个，每个命令前必须有一个==Tab缩进==并且==独占占一行==。

- **依赖(depend)**: 规则所**必需**的==依赖条件==，在规则的命令中可以使用这些依赖。

    - 例如：生成可执行文件的**目标文件**（*.o）可以作为依赖使用


    - 如果规则的命令中不需要任何依赖，那么规则的依赖**可以为空**
    
    - 当前规则中的依赖可以是其他规则中的**某个目标**，这样就形成了==规则之间的嵌套==
    
    - 依赖可以根据要执行的命令的实际需求，指定很**多个**

- **目标(target)**： 规则中的==目标==，这个目标和规则中的命令是对应的

    - 通过执行规则中的命令，可以生成一个**和目标同名**的文件

    - 规则中可以有**多个命令**，因此可以通过这多条命令来生成**多个目标**，所有目标也可以有很多个

    - 通过执行规则中的命令，可以只执行一个动作，**不生成任何文件**，这样的目标被称为**伪目标**

下面通过一个例子来阐述一下：

````shell
# 举例: 有源文件 a.c b.c c.c head.h, 需要生成可执行程序 app
################# 例1 #################
app:a.c b.c c.c
	gcc a.c b.c c.c -o app

################# 例2 #################
# 有多个目标, 多个依赖, 多个命令
app,app1:a.c b.c c.c d.c
	gcc a.c b.c -o app
	gcc c.c d.c -o app1
	
################# 例3 #################	
# 规则之间的嵌套
app:a.o b.o c.o
	gcc a.o b.o c.o -o app
# a.o 是第一条规则中的依赖
a.o:a.c
	gcc -c a.c
# b.o 是第一条规则中的依赖
b.o:b.c
	gcc -c b.c
# c.o 是第一条规则中的依赖
c.o:c.c
	gcc -c c.c
````

​	



## 2. 工作原理

​	在此主要剖析一下通过提供的 makefile 文件，构建工具 make 什么时候编译项目中的所有文件，什么时候只选择更新项目中的某几个文件。另外再研究一下如果 makefile 里边有多个规则它们之间是如何配合工作的，基于下边的例子，依次进行讲解。



### 2.1 规则的执行

调用 make 命令编译程序的时候，make 会**首先找到 Makefile 文件中的第 1 个规则**，分析并执行相关的动作。

但是需要注意的是，好多时候要执行的动作（命令）中使用的**依赖是不存在**的，如果使用的依赖不存在，这个动作也就不会被执行。

对应的解决方案是**先将需要的依赖生成出来**，我们就可以在 makefile 中**添加新的规则**，*将不存在的依赖作为这个新的规则中的目标，当这条新的规则对应的命令执行完毕，对应的目标就被生成了，同时另一条规则中需要的依*赖也就存在了。

这样，makefile 中的某一条规则在需要的时候，就会**被其他的规则调用**，*直到 makefile 中的第一条规则中的所有的依赖全部被生成*，第一条规则中的命令就可以*基于这些依赖生成对应的目标*，make 的任务也就完成了。

````makefile
# makefile
# 规则之间的嵌套
# 规则1
# make 发现没有 a.o b.o c.o 就先去找makefile中是否可以找到生成这些依赖的规则
# 找得到就去执行，到所有依赖都生成时，就调用这个规则；
app:a.o b.o c.o
	gcc a.o b.o c.o -o app
# 规则2
a.o:a.c
	gcc -c a.c
# 规则3
b.o:b.c
	gcc -c b.c
# 规则4
c.o:c.c
	gcc -c c.c
````

在这个例子中，如果执行 make 命令就会根据这个 makefile 中的 4 条规则编译这三个源文件。在解析第一条规则的时候发现里边的三个依赖都是**不存在的**，因此规则对应的命令也就不能被执行。

当依赖不存在的时候，make 就是**查找其他的规则**，看哪一条规则是用来生成需要的这个依赖的，找到之后就会执行这条规则中的命令。*因此规则 2， 规则 3， 规则 4 里的命令会相继被执行*，当规则 1 中依赖全部被生成之后对应的命令也就被执行了，*因此规则 1 的目标被生成，make 工作结束*。

如果想要执行 makefile 中非第一条规则对应的命令，那么就不能直接 make, 需要将那条规则的目标也写到 make 的后边，比如只需要执行规则 3 中的命令，就需要: make b.o。



### 2.2 文件的时间戳

make 命令执行的时候会根据==文件的时间戳==判定**是否执行** makefile 文件中相关规则中的命令。（时间戳大，表示文件更新）

- **目标是通过依赖生成的**，因此正常情况下：*目标时间戳 > 所有依赖的时间戳* , 如果执行 make 命令的时候检测到规则中的目标和依赖满足这个条件，那么规则中的命令就**不会被执行**。
- 当**依赖文件被更新了**，文件时间戳也会随之被更新，这时候 *目标时间戳 < 某些依赖的时间戳* , 在这种情况下目标文件会通过规则中的命令被**重新生成**。
- 如果规则中的目标对应的**文件根本就不存在**， 那么规则中的命令**肯定会被执行**。



### 2.3 自动推导

make 是一个功能强大的构建工具，虽然 make 需要根据 makefile 中指定的规则来完成源文件的编译。

作为小白的我们编写 makefile 的时候难免写的不是那么严谨从而漏写一些构建规则，但是我们会发现程序还是会被编译成功。这是因为 make 有==自动推导==的能力，不会完全依赖 makefile。

比如：使用命令 make 编译扩展名为.c 的 C 语言文件的时候，源文件的编译规则不用明确给出。这是因为 make 进行编译的时候会使用一个默认的编译规则，按照默认规则完成对.c 文件的编译，生成对应的.o 文件。它使用命令 cc -c 来编译.c 源文件。在 Makefile 中只要给出需要构建的目标文件名（一个.o 文件），make 会自动为这个.o 文件寻找合适的依赖文件（对应的.c 文件），并且使用默认的命令来构建这个目标文件。

假设本地项目目录中有以下几个源文件：

````shell
$ tree
.
├── add.c
├── div.c
├── head.h
├── main.c
├── makefile
├── mult.c
└── sub.c
````

​	使用 makefile

````makefile
# 这是一个完整的 makefile 文件
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
````

​	make!

````shell
$ make
cc    -c -o add.o add.c
cc    -c -o div.o div.c
cc    -c -o main.o main.c
cc    -c -o mult.o mult.c
cc    -c -o sub.o sub.c
gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
````

我们可以发现上边的 makefile 文件中只有一条规则，依赖中所有的 .o 文件在本地项目目录中是不存在的，并且也没有其他的规则用来生成这些依赖文件，这时候 make 会使用内部**默认的构造规则**先将这些依赖文件生成出来，然后在执行规则中的命令，最后生成目标文件 calc。





## 3. 变量

​	使用 Makefile 进行规则定义的时候，为了写起来更加灵活，我们可以在里边使用==变量==。

​	makefile 中的变量分为三种：**自定义变量**，**预定义变量**和**自动变量**。



### 3.1 自定义变量

​	用 Makefile 进行规则定义的时候，用户可以定义自己的变量，称为==用户自定义变量==。

​	makefile 中的变量是没有类型的，直接创建变量然后给其赋值就可以了：

````makefile
# 错误, 只创建了变量名, 没有赋值
变量名 
# 正确, 创建一个变量名并且给其赋值
变量名=变量值
````

​	在给 makefile 中的变量赋值之后，如何在需要的时候将变量值取出来：

````makefile
# 如果将变量的值取出?
$(变量的名字)

# 举例 add.o  div.o  main.o  mult.o  sub.o
# 定义变量并赋值
obj=add.o  div.o  main.o  mult.o  sub.o
# 取变量的值
$(obj)
````

​	自定义变量使用举例：

````makefile
# 这是一个规则，普通写法
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
        
# 这是一个规则，里边使用了自定义变量
obj=add.o  div.o  main.o  mult.o  sub.o
target=calc
$(target):$(obj)
        gcc  $(obj) -o $(target)
````

​	



### 3.2 预定义变量

​	在 Makefile 中有一些**已经定义的变量**，用户可以直接**使用这些变量**，不用进行定义。

​	在进行编译的时候，某些条件下 Makefile 会使用这些==预定义变量==的值进行编译。这些预定义变量的名字一般都是大写的，经常采用的预定义变量如下表所示：

|  变量名  |             含义             |  默认值  |
| :------: | :--------------------------: | :------: |
|    AR    |  生成静态库库文件的程序名称  |    ar    |
|    AS    |       汇编编译器的名称       |    as    |
|    CC    |      C 语言编译器的名称      |    cc    |
|   CPP    |     C 语言预编译器的名称     | $(CC) -E |
|   CXX    |     C++ 语言编译器的名称     |   g++    |
|    FC    |   FORTRAN 语言编译器的名称   |   f77    |
|    RM    |      删除文件程序的名称      |  rm -f   |
| ARFLAGS  |  生成静态库库文件程序的选项  | 无默认值 |
| ASFLAGS  |   汇编语言编译器的编译选项   | 无默认值 |
|  CFLAGS  |    C 语言编译器的编译选项    | 无默认值 |
| CPPFLAGS |   C 语言预编译器的编译选项   | 无默认值 |
| CXXFLAGS |   C++ 语言编译器的编译选项   | 无默认值 |
|  FFLAGS  | FORTRAN 语言编译器的编译选项 | 无默认值 |
|  VPATH   |     C/C++ 语言源文件路径     | 无默认值 |

````makefile
# 这是一个规则，普通写法
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
        
# 这是一个规则，里边使用了自定义变量和预定义变量
obj=add.o  div.o  main.o  mult.o  sub.o
target=calc
CFLAGS=-O3 # 代码优化
$(target):$(obj)
        $(CC)  $(obj) -o $(target) $(CFLAGS)
````



### 3.3 自动变量

​	Makefile 中的变量除了用户**自定义变量**和**预定义变量**外，还有一类==自动变量==。

​	Makefile 中的规则语句中经常会出现目标文件和依赖文件，自动变量用来代表这些规则中的**目标文件**和**依赖文件**，并且它们只能在**规则的命令**中使用。

​	下表中是一些常见的**自动变量**。

| 变量 | 含义                                                         |
| :--: | :----------------------------------------------------------- |
|  $*  | 表示**目标文件**的名称，不包含目标文件的扩展名               |
|  $+  | 表示**所有的依赖文件**，这些依赖文件之间以**空格分开**，按照出现的先后为顺序，其中可能 包含**重复**的依赖文件 |
|  $<  | 表示依赖项中**第一个依赖文件**的名称                         |
|  $?  | 依赖项中，所有比目标文件**时间戳晚的依赖文件**，依赖文件之间以空格分开 |
|  $@  | 表示**目标文件**的名称，包含文件扩展名                       |
|  $^  | 依赖项中，所有**不重复**的**依赖文件**，这些文件之间以空格分开 |


​	下面几个例子，演示一下自动变量如何使用。

````makefile
# 这是一个规则，普通写法
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
        
# 这是一个规则，里边使用了自定义变量
# 使用自动变量, 替换相关的内容
calc:add.o  div.o  main.o  mult.o  sub.o
	gcc $^ -o $@ 			# 自动变量只能在规则的命令中使用
````





## 4. 模式匹配

​	在介绍概念之前，先读一下下面的这个 makefile 文件：

````makefile
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
# 语法格式重复的规则, 将 .c -> .o, 使用的命令都是一样的 gcc *.c -c
add.o:add.c
        gcc add.c -c

div.o:div.c
        gcc div.c -c

main.o:main.c
        gcc main.c -c

sub.o:sub.c
        gcc sub.c -c

mult.o:mult.c
        gcc mult.c -c
````

​	在阅读过程中能够发现从第二个规则开始到第六个规则做的是**相同的事情**，但是由于**文件名不同**不得不在文件中写出多个规则，这就让 makefile 文件看起来非常的**冗余**，我们可以将这一系列的相同操作整理成**一个模板**，所有类似的操作都通过模板去匹配 makefile 会因此而**精简不少**，只是可读性会有所下降。

​	这个规则模板可以写成下边的样子，这种操作就称之为模式匹配。

````makefile
# 模式匹配 -> 通过一个公式, 代表若干个满足条件的规则
# 依赖有一个, 后缀为.c, 生成的目标是一个 .o 的文件, % 是一个通配符, 匹配的是文件名
%.o:%.c
	gcc $< -c
````

![image-20200418143747981](https://subingwen.cn/linux/makefile/image-20200418143747981-1611845766993.png)





## 5. 函数

​	makefile 中有很多==函数==并且所有的函数都是有==返回值==的。

​	makefile 中函数的格式和 C/C++ 中函数也不同，其写法是这样的： `$(函数名 参数1, 参数2, 参数3, ...)`，主要目的是让我们能够快速方便的**得到函数的返回值**。

​	这里介绍几个 makefile 中使用频率比较高的函数：



### 5.1 wildcard

​	这个函数的主要作用是获取指定目录下指定类型的文件名，其返回值是以空格分割的、指定目录下的所有符合条件的文件名列表。函数原型如下：

````makefile
# 该函数的参数只有一个, 但是这个参数可以分成若干个部分, 通过空格间隔
$(wildcard PATTERN...)
	参数:	指定某个目录, 搜索这个路径下指定类型的文件，比如： *.c
````

- **参数功能**:

    - `PATTERN` 指的是**某个或多个目录**下的对应的**某种类型的文件**，比如当前目录下的.c 文件可以写成 *.c

    - 可以指定**多个目录**，每个路径之间使用**空格间隔**

- **返回值**：
    - 得到的若干个文件的文件列表， 文件名之间使用空格间隔
    
    - 示例：`$(wildcard *.c ./sub/*.c)`
        - 返回值格式: a.c b.c c.c d.c e.c f.c ./sub/aa.c ./sub/bb.c

- **函数使用举例**：

````makefile
# 使用举例: 分别搜索三个不同目录下的 .c 格式的源文件
src = $(wildcard /home/robin/a/*.c /home/robin/b/*.c *.c)  # *.c == ./*.c
# 返回值: 得到一个大的字符串, 里边有若干个满足条件的文件名, 文件名之间使用空格间隔
/home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c
````



### 5.2 patsubst

​	这个函数的功能是*按照指定的模式替换指定的文件名的后缀*，函数原型如下：

````makefile
# 有三个参数, 参数之间使用 逗号间隔
$(patsubst <pattern>,<replacement>,<text>)
````

- **参数功能**:
    - `pattern`: 这是一个**模式字符串**，需要指定出要被替换的文件名中的**后缀**是什么
        - 文件名和路径不需要关心，因此使用 % 表示即可 [通配符是 %]
        - 在通配符后边指定出要被替换的后缀，比如: %.c, 意味着 .c 的后缀要被替换掉
    - `replacement`: 这是一个**模式字符串**，指定参数 `pattern` 中的后缀最终要被替换为什么
        - 还是使用 % 来表示参数 `pattern` 中文件的**路径和名字**
        - 在通配符 % 后边指定出新的后缀名，比如: %.o 这表示原来的后缀被替换为 .o
    - `text`: 该参数中存储这要被替换的**原始数据**
- **返回值**:
    - 函数返回被替换过后的字符串。

- **函数使用举例**：

````makefile
src = a.cpp b.cpp c.cpp e.cpp
# 把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o
obj = $(patsubst %.cpp, %.o, $(src)) 
# obj 的值为: a.o b.o c.o e.o
````



### 5.3 notdir

​	这个函数的功能是去掉文件的路径

````makefile
# 有一个参数
$(notdir <text>)
````

- **参数功能**
    - `<text>`：给出一系列带路径的文件，以空格间隔；
- **返回值：**
    - 返回去出路径的文件，以空格间隔

- **函数使用举例**：

````makefile
srcs = ./src/Application.cpp ./src/add/add.cpp ./src/sub/sub.cpp
# 去掉文件的路径
srcs_nodir = $(notdir $(srcs) )
# srcs_nodif = Application.cpp add.cpp sub.cpp
````



### 5.4 addprefix

​	此函数用来给文件加上路径

````makefile
# 两个参数
$(addprefix <addstuff>, <text>)
````

- **参数功能**：
    - `<addstuff>`：需要加上的内容；
    - `<text>`：需要加内容的原文本，可以有多个，以空格分开；
- **返回值**：
    - 返回在 `<text>` 中每个元素前加上 `addstuff` 的新文本；

- **函数使用举例**

````makefile
# objs_nodif = Application.o add.o sub.o
# 给这些目标文件加上前缀
objs = $(addprefix bin/obj/, $(obj_nodir))
# objs = bin/obj/Application.o bin/obj/add.o bin/obj/sub.o
````



### 5.5 foreach

​	此函数实现循环的功能

````makefile
SRCS := $(foreach dir, $(SRC_PATH), $(wildcard $(dir)/*.cpp))
# 三个参数
$(foreach <temp>, <loop_objs>, <cmd>)
# 每次把 loop_objs 里的一个元素幅值给 temp，然后去执行 cmd，返回各个temp的执行结果
````

- **参数功能：**
    - `<temp>`：一个临时变量，只在这个函数内部起作用，给个名字就好；
    - `<loop_objs>`：里面应该是若干个以空格分开的内容，循环就是每次按顺序把其中一个幅值给 `temp`然后去执行 `cmd`；
    - `<cmd>`：一条操作临时变量 `temp` 的命令；
- **返回值**：
    - 返回各个 `temp` 执行 `cmd` 的结果，以空格分开
- **函数使用举例：**

````makefile
SRC_PATH = ./src ./src/add ./src/sub
# 依次取出 SRC_PATH 中的每一个元素给 dir，去执行 $(wildcard $(dir)/*.cpp) 取出每个目录下的.cpp
SRCS := $(foreach dir, $(SRC_PATH), $(wildcard $(dir)/*.cpp))
# SRCS = ./src/Application.cpp ./src/add/add.cpp ./src/sub/sub.cpp
````





​	